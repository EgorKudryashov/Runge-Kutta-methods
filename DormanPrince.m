function [X, Y] = DormanPrince(F, x_0, y_0, h, rightBorder, tol)
    A = [0 0 0 0 0 0 0;
         1/5 0 0 0 0 0 0;
         3/40 9/40 0 0 0 0 0;
         44/45 -56/15 32/9 0 0 0 0;
         19372/6561 -25360/2187 64448/6561 -212/729 0 0 0;
         9017/3168 -355/33 46732/5247 49/176 -5103/18656 0 0;
         35/384 0 500/1113 125/192 -2187/6784 11/84 0];
    B6 = [35/384 0 500/1113 125/192 -2187/6784 11/84 0];
    B7 = [5179/57600 0 7571/16695 393/640 -92097/339200 187/2100 1/40];
    C = [0 1/5 3/10 4/5 8/9 1 1];
    
    %Определяем начальные условия
    p = 5; %порядок сходимости
    v = 0; X = []; % rank= length(F); k = zeros(state, rank); Y_1 = zeros(1,rank);
    v = v + 1;
    X(v) = (x_0);
    Y = y_0;
    
    while (x_0 < rightBorder)
        Y_6 = Step (F, A,B6,C, h, x_0, y_0);
        Y_7 = Step (F, A,B7,C, h, x_0, y_0);
        
        %%%%Находим погрешность
        r_n = norm(abs(Y_7 - Y_6)) / ((2^(p)-1));
        
        %%%%Делаем выбор%%%%%%%%%%%%%%%%%%%%%%%%%%
        v = v + 1;
        %1 условие, плохо, пересчитываем шаг 
        while ( r_n > (tol*2^p) )
            h = h/2;
            Y_6 = Step (F, A,B6,C, h, x_0, y_0);
            Y_7 = Step (F, A,B7,C, h, x_0, y_0);
            %%Находим погрешность
            r_n = norm(abs(Y_7 - Y_6)) / ((2^(p)-1));
        end
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %2 условие, хорошо, но шаг уменьшаем на некст шаг
        if (tol<r_n) && (r_n<=tol*2^p) 
            x_0 = x_0 + h;
            y_0 = Y_7';

            h = h/2;
        end

        %3 условие, супер, шаг оставляем
        if (tol*(1/2^(p+1))<=r_n) && (r_n<=tol)
            x_0 = x_0 + h;
            y_0 = Y_7';
        end

        %4 условие,очень точно, увеличиваем шаг
        if (r_n<tol*(1/(2^(p+1))))    
            x_0 = x_0 + h;
            y_0 = Y_7';

            h = h * 2;
        end
        
        X(v) = (x_0);
        Y = [Y, y_0];   
    end
    
end

